import{_ as e,c as i,o as a,a as r}from"./app.3775c9dd.js";const m=JSON.parse('{"title":"Overview","description":"","frontmatter":{},"headers":[{"level":2,"title":"How actually an eBPF program is run","slug":"how-actually-an-ebpf-program-is-run","link":"#how-actually-an-ebpf-program-is-run","children":[{"level":3,"title":"Kernel space","slug":"kernel-space","link":"#kernel-space","children":[]},{"level":3,"title":"User space (with libbpf)","slug":"user-space-with-libbpf","link":"#user-space-with-libbpf","children":[]},{"level":3,"title":"Variations","slug":"variations","link":"#variations","children":[]}]}],"relativePath":"overview.md","lastUpdated":1672991337000}'),t={name:"overview.md"},l=r('<h1 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-hidden="true">#</a></h1><h2 id="how-actually-an-ebpf-program-is-run" tabindex="-1">How actually an eBPF program is run <a class="header-anchor" href="#how-actually-an-ebpf-program-is-run" aria-hidden="true">#</a></h2><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>The following description may differ from the actual implementation in Linux or libbpf.</p></div><h3 id="kernel-space" tabindex="-1">Kernel space <a class="header-anchor" href="#kernel-space" aria-hidden="true">#</a></h3><ol><li>eBPF programs are passed into the kernel with the <a href="./user/syscall.html"><code>BPF(2)</code></a> syscall, which mainly contains the following info: <ul><li>Program type, license, version, size...</li><li>The raw program, or rather, an array of eBPF instructions</li><li>Optionally some debug info</li></ul></li><li>The instructions are checked by the verifier.</li><li>Things (e.g., pointers to maps) are relocated.</li><li>If JIT compilation is enabled, the JIT module compiles the instructions into native code.</li><li>A file descriptor is allocated for the eBPF program.</li><li>Upon running, either <ul><li>the interpreter interprets the instructions,</li><li>or the compiled native code runs directly.</li><li>(We allocate a new stack frame for each function call.)</li></ul></li></ol><h3 id="user-space-with-libbpf" tabindex="-1">User space (with libbpf) <a class="header-anchor" href="#user-space-with-libbpf" aria-hidden="true">#</a></h3><ol><li>The user writes the eBPF program in C.</li><li>LLVM compiles the source into eBPF instructions, saving them into an ELF file along with relocation information, debug information, etc.</li><li>Libbpf reads in the ELF file, parses it, and acts according to section names: <ul><li>Some maps are configured.</li><li>BPF programs are adjusted with BTF info from the kernel to ensure <a href="https://nakryiko.com/posts/bpf-portability-and-co-re/" target="_blank" rel="noreferrer">CO-RE</a>.</li><li>Things (jump destinations, for example) are relocated.</li><li>The programs are submitted to the kernel with the <code>BPF(2)</code> syscall.</li></ul></li></ol><h3 id="variations" tabindex="-1">Variations <a class="header-anchor" href="#variations" aria-hidden="true">#</a></h3><p>Yes, eBPF is ever evolving. It does seem that kernel developers are moving relocations from libbpf into the kernel so that the compiled eBPF instructions stay immutable. See <a href="./user/syscall.html#bpf-prog-load">some notes on the syscall interface</a>.</p>',9),o=[l];function n(s,c,h,p,d,u){return a(),i("div",null,o)}const b=e(t,[["render",n]]);export{m as __pageData,b as default};
