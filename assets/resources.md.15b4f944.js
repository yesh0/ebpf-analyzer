import{_ as e,c as r,o as t,a}from"./app.3775c9dd.js";const f=JSON.parse('{"title":"Resources","description":"","frontmatter":{},"headers":[{"level":2,"title":"Source code","slug":"source-code","link":"#source-code","children":[]},{"level":2,"title":"Kernel documentation","slug":"kernel-documentation","link":"#kernel-documentation","children":[]},{"level":2,"title":"Third party documentation","slug":"third-party-documentation","link":"#third-party-documentation","children":[]},{"level":2,"title":"eBPF programming","slug":"ebpf-programming","link":"#ebpf-programming","children":[]}],"relativePath":"resources.md","lastUpdated":1672991337000}'),o={name:"resources.md"},i=a('<h1 id="resources" tabindex="-1">Resources <a class="header-anchor" href="#resources" aria-hidden="true">#</a></h1><h2 id="source-code" tabindex="-1">Source code <a class="header-anchor" href="#source-code" aria-hidden="true">#</a></h2><p>eBPF is always evolving, and obviously the kernel documentation is not following up. To get a better understanding of eBPF, you should always check out the kernel source code.</p><p>Don&#39;t panic. Linux source code is neat.</p><ul><li><p>The kernel interpreter:</p><ul><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/core.c#L1643" target="_blank" rel="noreferrer"><code>kernel/bpf/core.c#___bpf_prog_run</code></a></li></ul></li><li><p>The kernel verifier:</p><ul><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/include/linux/bpf_verifier.h" target="_blank" rel="noreferrer">The header at <code>linux/bpf_verifier.h</code></a></li><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c" target="_blank" rel="noreferrer">Most of the code is at <code>kernel/bpf/verifier.c</code></a>: you might want to start reading at the end of the file where <code>bpf_check</code> lies.</li></ul></li><li><p>The kernel JIT compilers:</p><ul><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/arch/riscv/net/bpf_jit.h" target="_blank" rel="noreferrer">Header for riscv64</a></li><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/arch/riscv/net/bpf_jit_comp64.c" target="_blank" rel="noreferrer">Code for riscv64</a></li></ul><p>The eBPF VM is actually designed to be RISC, so JIT compilers for RISC architectures can be more understandable (provided that you are willing to learn about it).</p></li><li><p>The syscall interface:</p><ul><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/syscall.c" target="_blank" rel="noreferrer"><code>kernel/bpf/syscall.c</code></a></li><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/include/uapi/linux/bpf.h" target="_blank" rel="noreferrer"><code>include/uapi/linux/bpf.h</code></a></li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>When reading lengthy code, an IDE really makes your life better. (I mainly use one to collapse the code I have comprehended.)</p><p>Personally I find <code>github.dev</code> satisfactory. For any GitHub URL, replacing <code>github.com</code> with <code>github.dev</code> does the job.</p></div><h2 id="kernel-documentation" tabindex="-1">Kernel documentation <a class="header-anchor" href="#kernel-documentation" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Ongoing efforts to update relevant documentation:</p><ul><li><p><a href="https://github.com/dthaler/ebpf-docs/pull/4" target="_blank" rel="noreferrer">Update ISA documentation</a></p><p>The updated ISA draft lies <a href="https://github.com/dthaler/ebpf-docs/blob/update/isa/kernel.org/instruction-set.rst" target="_blank" rel="noreferrer">here</a>.</p></li><li><p><a href="https://github.com/iovisor/bpf-docs/pull/26" target="_blank" rel="noreferrer">eBPF.md: Add missing instructions and instruction variants (32-bit jumps, atomic instructions, call and lddw variants)</a></p></li></ul></div><p>Despite being a little bit outdated, the kernel documentation documents the gist of some decisions and can give you a vague impression of how things work.</p><ul><li><a href="https://docs.kernel.org/bpf/instruction-set.html" target="_blank" rel="noreferrer">The instruction set &quot;specification&quot;</a> is too incomplete to be a spec but can be a good starting point.</li><li><a href="https://docs.kernel.org/bpf/verifier.html" target="_blank" rel="noreferrer">The verifier documentation</a> provides an overview of the verifier implementation. <ul><li>The verifier supports some bounded loops now. Check out the LWN article <a href="https://lwn.net/Articles/794934/" target="_blank" rel="noreferrer">Bounded loops in BPF for the 5.3 kernel</a> for more details.</li></ul></li><li><a href="https://docs.kernel.org/bpf/btf.html" target="_blank" rel="noreferrer">An introduction to BTF</a> introduce you to a format storing symbol names, function signatures and other debug info.</li><li><a href="https://man7.org/linux/man-pages/man2/bpf.2.html" target="_blank" rel="noreferrer"><code>man 2 bpf</code></a> documents some important syscall <code>cmd</code>.</li><li><a href="https://docs.kernel.org/userspace-api/ebpf/syscall.html" target="_blank" rel="noreferrer">bpf() subcommand reference</a> seems more complete than the previous one.</li></ul><h2 id="third-party-documentation" tabindex="-1">Third party documentation <a class="header-anchor" href="#third-party-documentation" aria-hidden="true">#</a></h2><p>Third party documents and blog are good. Things may change, but the code structure as well as the ABI usually stays the same.</p><p>Here is a non-exhaustive list, and you can always search for ones that suit your need.</p><ul><li><a href="https://docs.cilium.io/en/latest/bpf/" target="_blank" rel="noreferrer">BPF and XDP Reference Guide - Cilium documentation</a></li><li><a href="https://blogs.oracle.com/linux/post/bpf-application-development-and-libbpf" target="_blank" rel="noreferrer">A series of blog posts about BPF - Oracle Linux Blog</a></li><li><a href="https://www.containiq.com/post/libbpf" target="_blank" rel="noreferrer">Libbpf: A Beginners Guide - ContainIQ</a></li><li><a href="https://medium.com/@c0ngwang/understanding-struct-sk-buff-730cf847a722" target="_blank" rel="noreferrer">Understanding struct __sk_buff</a>: Talks about context access conversion</li></ul><h2 id="ebpf-programming" tabindex="-1">eBPF programming <a class="header-anchor" href="#ebpf-programming" aria-hidden="true">#</a></h2><ul><li><p><a href="https://github.com/xdp-project/xdp-tutorial" target="_blank" rel="noreferrer">XDP Programming Hands-On Tutorial</a>: While it focuses on XDP, it covers libbpf usages and some eBPF caveats. If you want to take a glimpse into user space eBPF programming (with libbpf), this is absolutely a good starting point.</p></li><li><p><a href="https://sysdig.com/blog/the-art-of-writing-ebpf-programs-a-primer/" target="_blank" rel="noreferrer">The art of writing eBPF programs: a primer.</a>: An introduction to writing eBPF programs attaching to trace points.</p></li></ul>',16),n=[i];function l(c,s,d,u,p,h){return t(),r("div",null,n)}const m=e(o,[["render",l]]);export{f as __pageData,m as default};
