import{_ as s,c as a,o as e,a as n}from"./app.3775c9dd.js";const h=JSON.parse('{"title":"Arithmetic Operation Verification","description":"","frontmatter":{},"headers":[{"level":2,"title":"check_alu_op","slug":"check-alu-op","link":"#check-alu-op","children":[{"level":3,"title":"adjust_scalar_min_max_vals","slug":"adjust-scalar-min-max-vals","link":"#adjust-scalar-min-max-vals","children":[]},{"level":3,"title":"adjust_ptr_min_max_vals","slug":"adjust-ptr-min-max-vals","link":"#adjust-ptr-min-max-vals","children":[]}]}],"relativePath":"verifier/arithmetic.md","lastUpdated":1672991337000}'),l={name:"verifier/arithmetic.md"},o=n(`<h1 id="arithmetic-operation-verification" tabindex="-1">Arithmetic Operation Verification <a class="header-anchor" href="#arithmetic-operation-verification" aria-hidden="true">#</a></h1><p><a href="./verifier.html#do-check"><code>do_check</code></a> calls <a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L9229" target="_blank" rel="noreferrer"><code>check_alu_op</code></a> to check arithmetic operations and update tracked values.</p><h2 id="check-alu-op" tabindex="-1"><code>check_alu_op</code> <a class="header-anchor" href="#check-alu-op" aria-hidden="true">#</a></h2><blockquote><p>This functions checks ALU operations (32-bit &amp; 64-bit):</p><ol><li>Checks non arithmetic operations: <code>BPF_END</code>, <code>BPF_NEG</code> and <code>BPF_MOV</code>;</li><li>Dispatches arithmetic verification to <code>adjust_reg_min_max_vals</code>.</li></ol></blockquote><p>Some of the checks done in this function:</p><ol><li>Reserved fields must be zeroed.</li><li>Some pointer operations are prohibited: <ul><li>All pointer arithmetic <ul><li>Pointer subtraction is not strictly checked (i.e., the result is marked as unknown) and is only allowed if <code>allow_ptr_leaks</code>.</li></ul></li><li>Partial copy of a pointer</li></ul></li><li><code>R10</code> is not writable while uninitialized registers are not readable. (See <a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L2449" target="_blank" rel="noreferrer"><code>check_reg_arg</code></a>.)</li><li>Division by zero or undefined shifts (e.g., <code>u64 &lt;&lt; 65</code>) are prohibited.</li></ol><p>Side effects:</p><ol><li>Register status update: <code>mark_reg_scratched</code>, <code>mark_reg_read</code>, <code>mark_reg_unknown</code>.</li><li>Instance mark: <code>mark_insn_zext</code>.</li><li>Register scalar value update: <code>adjust_reg_min_max_vals</code>, which calls <code>adjust_scalar_min_max_vals</code>.</li><li>Register pointer value update: <code>adjust_ptr_min_max_vals</code>.</li></ol><table><thead><tr><th><code>src</code> \\ <code>dst</code></th><th>Pointer</th><th>Scalar</th></tr></thead><tbody><tr><td>Pointer</td><td>Forbidden unless subtracting</td><td><code>adjust_ptr_min_max_vals</code></td></tr><tr><td>Scalar</td><td><code>adjust_ptr_min_max_vals</code></td><td><code>adjust_scalar_min_max_vals</code></td></tr></tbody></table><div class="info custom-block"><p class="custom-block-title">Precise value tracking</p><p>Precise value tracking was introduced in this comment: <a href="https://github.com/torvalds/linux/commit/b5dc0163d8fd78e64a7e21f309cf932fda34353e" target="_blank" rel="noreferrer">bpf: precise scalar_value tracking</a>.</p><p>You should read through the commit message to grasp the gist and what each function does.</p><p>Also, I am quoting from <a href="https://lwn.net/Articles/795367/" target="_blank" rel="noreferrer">a comment in a LWN article</a>: it seems that the verifier always keeps the precise values, and marking a value as being &quot;precise&quot; just prevents it getting pruned. If it is so, this part mostly has more to do with branch pruning than actual ALU operations.</p></div><h3 id="adjust-scalar-min-max-vals" tabindex="-1"><code>adjust_scalar_min_max_vals</code> <a class="header-anchor" href="#adjust-scalar-min-max-vals" aria-hidden="true">#</a></h3><p>This function dispatches operations to:</p><ul><li><code>scalar_min_max_add</code>: Addition</li><li><code>scalar_min_max_sub</code>: Subtraction</li><li><code>scalar_min_max_mul</code>: Multiplication</li><li><code>scalar_min_max_and</code>: Bit-wise AND</li><li><code>scalar_min_max_or</code>: Bit-wise OR</li><li><code>scalar_min_max_xor</code>: Bit-wise XOR</li><li><code>scalar_min_max_lsh</code>: Left shift</li><li><code>scalar_min_max_rsh</code>: Right shift (unsigned)</li><li><code>scalar_min_max_arsh</code>: Right shift (sign bit extending)</li></ul><p>Basically they update the <code>tnum</code> field and the min/max fields of a scalar:</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/include/linux/bpf_verifier.h#L147-L166</span></span>
<span class="line"><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> bpf_reg_state </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// ...</span></span>
<span class="line"><span style="color:#676E95;">  /* For scalar types (SCALAR_VALUE), this represents our knowledge of</span></span>
<span class="line"><span style="color:#676E95;">   * the actual value.</span></span>
<span class="line"><span style="color:#676E95;">   * For pointer types, this represents the variable part of the offset</span></span>
<span class="line"><span style="color:#676E95;">   * from the pointed-to object, and is shared with all bpf_reg_states</span></span>
<span class="line"><span style="color:#676E95;">   * with the same id as us.</span></span>
<span class="line"><span style="color:#676E95;">   */</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> tnum var_off</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;">  /* Used to determine if any memory access using this register will</span></span>
<span class="line"><span style="color:#676E95;">   * result in a bad access.</span></span>
<span class="line"><span style="color:#676E95;">   * These refer to the same value as var_off, not necessarily the actual</span></span>
<span class="line"><span style="color:#676E95;">   * contents of the register.</span></span>
<span class="line"><span style="color:#676E95;">   */</span></span>
<span class="line"><span style="color:#F07178;">  s64 smin_value</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;"> /* minimum possible (s64)value */</span></span>
<span class="line"><span style="color:#F07178;">  s64 smax_value</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;"> /* maximum possible (s64)value */</span></span>
<span class="line"><span style="color:#F07178;">  u64 umin_value</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;"> /* minimum possible (u64)value */</span></span>
<span class="line"><span style="color:#F07178;">  u64 umax_value</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;"> /* maximum possible (u64)value */</span></span>
<span class="line"><span style="color:#F07178;">  s32 s32_min_value</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;"> /* minimum possible (s32)value */</span></span>
<span class="line"><span style="color:#F07178;">  s32 s32_max_value</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;"> /* maximum possible (s32)value */</span></span>
<span class="line"><span style="color:#F07178;">  u32 u32_min_value</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;"> /* minimum possible (u32)value */</span></span>
<span class="line"><span style="color:#F07178;">  u32 u32_max_value</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;"> /* maximum possible (u32)value */</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// ...</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre></div><h4 id="implementation-details" tabindex="-1">Implementation details <a class="header-anchor" href="#implementation-details" aria-hidden="true">#</a></h4><p>If ever you would like to peek into the implementation details, here are some notes:</p><ol start="0"><li><p>Maintained fields:</p><ul><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/tnum.c" target="_blank" rel="noreferrer"><code>struct tnum</code></a>: tracks the individual bits in the scalar, consisting of a mask (masked bits are unknown) and a value (recording the unmasked known bits).</li><li>minimum/maximum possible values for <code>u64/i64/u32/i32</code> respectively.</li></ul></li><li><p>Before dispatching, <code>adjust_scalar_min_max_vals</code> tries to:</p><ul><li>Validate the register state (e.g., <code>min_value &lt;= max_value</code>);</li><li>Ensure <code>src_known</code> for some opcodes (e.g., shifts), or set the register as unknown;</li><li>Sanitize something that is probably part of branch tracking or pruning...</li></ul><p><code>adjust_scalar_min_max_vals</code> has undergone refactoring, which moved portions of it out into functions like <code>scalar(32)_min_max_...</code>. When reading the processing logic in <code>scalar(32)_min_max_...</code>, you should always take note that some of these functions require <code>src_known</code>, that is, <strong>some of them assume that <code>src_reg</code> is a constant</strong>.</p></li><li><p>In that big <code>switch</code> block in <code>adjust_scalar_min_max_vals</code>:</p><ul><li>For some opcodes, <code>dst_reg-&gt;var_off</code> is changed before calling <code>scalar(32)_min_max_...</code>; <ul><li>These opcodes are <code>BPF_ADD</code> and <code>BPF_SUB</code>, whose <code>scalar(32)_min_max_...</code> functions are independent of <code>dst_reg-&gt;var_off</code>.</li></ul></li><li>For some other opcodes, <code>dst_reg-&gt;var_off</code> is assigned after calling <code>scalar(32)_min_max_...</code>;</li><li>Shifts assign to <code>dst_reg-&gt;var_off</code> inside <code>scalar(32)_min_max_...</code>.</li></ul></li><li><p>The actual logic inside <code>scalar(32)_min_max_...</code> functions:</p><ul><li>Operations other than <code>and</code>, <code>or</code> and <code>mul</code> require <code>src_known</code>, although some of them could handle unknown <code>src_reg</code> in principle.</li><li>Bit-wise operations (<code>and</code>, <code>or</code>, <code>xor</code>) are quite straightforward.</li><li>For <code>add</code>, <code>sub</code> and <code>mul</code>, uh, you might want to check out this essay: <a href="https://arxiv.org/abs/2105.05398" target="_blank" rel="noreferrer">[arXiv:2105.05398] Sound, Precise, and Fast Abstract Interpretation with Tristate Numbers</a>.</li><li>For shifts, things are quite easy if you bear in mind that they require a <strong>constant <code>src_reg</code></strong>.</li></ul></li><li><p><code>adjust_scalar_min_max_vals</code> calls <code>reg_bounds_sync</code> after updating the fields. It is quite crucial since it syncs the bit map (<code>var_off</code>) with sign bit info.</p><p>In functions for <code>and</code>, <code>or</code>, <code>xor</code>, you will find that they assume <code>var_off</code> is in sync. The following code assumes that a positive <code>smin_value</code> implies a synced <code>var_off</code> with its sign bit cleared.</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki has-highlighted-lines"><code><span class="line"><span style="color:#676E95;">// https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L8622-L8655</span></span>
<span class="line"><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">scalar_min_max_and</span><span style="color:#89DDFF;">(...)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// ...</span></span>
<span class="line highlighted"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">dst_reg</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">umin_value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">dst_reg</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">var_off</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line highlighted"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">dst_reg</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">umax_value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">min</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">dst_reg</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">umax_value</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> umax_val</span><span style="color:#89DDFF;">);</span><span style="color:#F07178;"> </span></span>
<span class="line highlighted"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">if</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">dst_reg</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">smin_value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">||</span><span style="color:#F07178;"> smin_val </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// ...</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;">    /* ANDing two positives gives a positive, so safe to</span></span>
<span class="line"><span style="color:#676E95;">     * cast result into s64.</span></span>
<span class="line"><span style="color:#676E95;">     */</span></span>
<span class="line highlighted"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">dst_reg</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">smin_value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">dst_reg</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">umin_value</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line highlighted"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">dst_reg</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">smax_value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">dst_reg</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">umax_value</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// ...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ol><h3 id="adjust-ptr-min-max-vals" tabindex="-1"><code>adjust_ptr_min_max_vals</code> <a class="header-anchor" href="#adjust-ptr-min-max-vals" aria-hidden="true">#</a></h3><p>This function is quite similar to <code>adjust_scalar_min_max_vals</code>, utilizing very much the same fields (<code>s(u)min(max)_val</code>).</p><ul><li>Operations allowed: <ul><li>64-bit addition: <code>ptr += scalar</code> or <code>scalar += ptr</code>.</li><li>64-bit subtraction: <code>ptr -= scalar</code>.</li><li>32-bit subtraction allowed only if <code>allow_ptr_leaks</code> is enabled</li></ul></li><li>Operations disallowed: <ul><li>Arithmetic on null-able pointers</li><li>Adding/Subtracting non-zero values to/from a <code>CONST_PTR_TO_MAP</code></li><li>Arithmetic on <code>PTR_TO_PACKET_END</code>, <code>PTR_TO_SOCKET</code>, <code>PTR_TO_SOCK_COMMON</code>, <code>PTR_TO_TCP_SOCK</code>, <code>PTR_TO_XDP_SOCK</code>...</li><li>Subtraction from stack pointer</li><li>Some insane operations, e.g. <code>ptr += u64::MAX</code> (See <a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L7832" target="_blank" rel="noreferrer"><code>check_reg_sane_offset</code></a> for details)</li></ul></li></ul><p>Some extra work:</p><ul><li>Arithmetic operations clear the range of <code>pkt_ptr</code>.</li><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L7971" target="_blank" rel="noreferrer"><code>sanitize_ptr_alu</code></a>: No idea yet.</li></ul><p>(WIP) </p>`,24),t=[o];function c(i,r,p,d,u,_){return e(),a("div",null,t)}const y=s(l,[["render",c]]);export{h as __pageData,y as default};
