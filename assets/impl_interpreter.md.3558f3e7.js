import{_ as t,c as e,o as d,a as o}from"./app.3775c9dd.js";const u=JSON.parse('{"title":"eBPF Interpreter Implementation","description":"","frontmatter":{},"headers":[{"level":2,"title":"Notes","slug":"notes","link":"#notes","children":[]}],"relativePath":"impl/interpreter.md","lastUpdated":1672991337000}'),r={name:"impl/interpreter.md"},n=o('<h1 id="ebpf-interpreter-implementation" tabindex="-1">eBPF Interpreter Implementation <a class="header-anchor" href="#ebpf-interpreter-implementation" aria-hidden="true">#</a></h1><p>The Linux interpreter lies here: <a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/core.c#L1643" target="_blank" rel="noreferrer"><code>kernel/bpf/core.c#___bpf_prog_run</code></a></p><p>To understand what exactly each instruction means and their undefined behaviors, given that no documentation ever states that (for now), we have to look into an actual, official implementation.</p><p>The following table uses a lot macros:</p><ul><li><code>u64 *regs</code>: The array of the registers,</li><li><code>#define DST regs[insn-&gt;dst_reg]</code>: the <code>dst_reg</code>,</li><li><code>#define SRC regs[insn-&gt;src_reg]</code>: the <code>src_reg</code>,</li><li><code>#define IMM insn-&gt;imm</code>: the immediate number (which is <code>i32</code> by the way).</li></ul><p>To save some space, when <code>SRC</code> and <code>IMM</code> follows the same pattern, I am going to skip the latter.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Just in case someone forgets about type conversions in C like me, <code>(u64_v) op (i32_v)</code> actually does <code>(u64_v) op (i32_v as i64 as u64)</code> in Rust.</p></div><table><thead><tr><th>Ops / Variant</th><th>Code</th><th>Notes</th></tr></thead><tbody><tr><td>Shifts (64-bit)</td><td><code>DST = DST OP (SRC &amp; 63)</code></td><td></td></tr><tr><td>Shifts (32-bit)</td><td><code>DST = (u32) DST OP ((u32) SRC &amp; 31)</code></td><td>Upper-half zeroed</td></tr><tr><td>Shifts (s64)</td><td><code>(*(s64 *) &amp;DST) &gt;&gt;= (SRC &amp; 63)</code></td><td></td></tr><tr><td>Shifts (s32)</td><td><code>DST = (u64) (u32) (((s32) DST) &gt;&gt; (SRC &amp; 31))</code></td><td>Upper-half zeroed</td></tr><tr><td>ALU (64-bit)</td><td><code>DST = DST OP SRC</code></td><td><code>+ - &amp; | ^ *</code></td></tr><tr><td>ALU (32-bit)</td><td><code>DST = (u32) DST OP (u32) SRC</code></td><td>Upper-half zeroed</td></tr><tr><td>ALU (NEG64)</td><td><code>DST = -DST</code></td><td></td></tr><tr><td>ALU (NEG32)</td><td><code>DST = (u32) -DST</code></td><td>Upper-half zeroed</td></tr><tr><td>ALU (MOV64)</td><td><code>DST = SRC</code></td><td></td></tr><tr><td>ALU (MOV32)</td><td><code>DST = (u32) SRC</code></td><td>Upper-half zeroed</td></tr><tr><td>ALU (MOV_K 64)</td><td><code>DST = (__s32) IMM</code></td><td>Sign-extending</td></tr><tr><td><code>LD_IMM_DW</code></td><td>See <a href="./../user/spec.html"><code>LD_IMM_DW</code></a></td><td></td></tr><tr><td>MOD (64-bit)</td><td><code>div64_u64_rem(DST, SRC, &amp;AX); DST = AX;</code></td><td>Unknown</td></tr><tr><td>MOD (32-bit)</td><td><code>AX = (u32) DST; DST = do_div(AX, (u32) SRC);</code></td><td>Unknown</td></tr><tr><td>DIV (64-bit)</td><td><code>DST = div64_u64(DST, SRC)</code></td><td>Unknown</td></tr><tr><td>DIV (32-bit)</td><td><code>AX = (u32) DST; do_div(AX, (u32) SRC); DST = (u32) AX;</code></td><td>Unknown</td></tr><tr><td>Endianness</td><td><code>DST = (__force u??) cpu_to_be??(DST)</code></td><td>Upper bits zeroed</td></tr><tr><td>Function calls</td><td>Pre-processed by the verifier. Skipping.</td><td></td></tr><tr><td>JMP</td><td><code>insn += insn-&gt;off</code></td><td><code>+1</code> by outer loop</td></tr><tr><td>Conditional JMP</td><td><code>if ((SIGN##64) DST CMP_OP (SIGN##64) SRC) { ... }</code></td><td>Casts</td></tr><tr><td>STX</td><td><code>*(SIZE *)(unsigned long) (DST + insn-&gt;off) = SRC</code></td><td>Casts</td></tr><tr><td>ST</td><td><code>*(SIZE *)(unsigned long) (DST + insn-&gt;off) = IMM</code></td><td>Casts?</td></tr><tr><td>LDX</td><td><code>DST = *(SIZE *)(unsigned long) (SRC + insn-&gt;off)</code></td><td>Casts</td></tr><tr><td>Atomic</td><td>...</td><td>WIP</td></tr></tbody></table><h2 id="notes" tabindex="-1">Notes <a class="header-anchor" href="#notes" aria-hidden="true">#</a></h2><p>Note that the interpreter implementation is not necessarily the actual specification.</p>',10),c=[n];function i(a,s,p,l,S,h){return d(),e("div",null,c)}const f=t(r,[["render",i]]);export{u as __pageData,f as default};
