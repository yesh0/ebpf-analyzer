import{_ as e,c as t,o as n,a as s}from"./app.3775c9dd.js";const b=JSON.parse('{"title":"Instruction Set Specification","description":"","frontmatter":{},"headers":[{"level":2,"title":"Standardization efforts","slug":"standardization-efforts","link":"#standardization-efforts","children":[]},{"level":2,"title":"Architecture","slug":"architecture","link":"#architecture","children":[]},{"level":2,"title":"Instruction Encoding","slug":"instruction-encoding","link":"#instruction-encoding","children":[{"level":3,"title":"Wide instructions","slug":"wide-instructions","link":"#wide-instructions","children":[]}]},{"level":2,"title":"Instructions","slug":"instructions","link":"#instructions","children":[{"level":3,"title":"Arithmetic and jumps","slug":"arithmetic-and-jumps","link":"#arithmetic-and-jumps","children":[]},{"level":3,"title":"Function calls","slug":"function-calls","link":"#function-calls","children":[]},{"level":3,"title":"Relocation","slug":"relocation","link":"#relocation","children":[]}]}],"relativePath":"user/spec.md","lastUpdated":1672991337000}'),a={name:"user/spec.md"},o=s(`<h1 id="instruction-set-specification" tabindex="-1">Instruction Set Specification <a class="header-anchor" href="#instruction-set-specification" aria-hidden="true">#</a></h1><p>The <a href="https://docs.kernel.org/bpf/instruction-set.html" target="_blank" rel="noreferrer">&quot;eBPF Instruction Set Specification, v1.0&quot;</a> is outdated and incomplete. Although eBPF is not strictly versioned, it does seem that it is far beyond &quot;v1.0&quot;.</p><p>This page aims to be a &quot;diff&quot; between that spec and current kernel implementation.</p><h2 id="standardization-efforts" tabindex="-1">Standardization efforts <a class="header-anchor" href="#standardization-efforts" aria-hidden="true">#</a></h2><p><a href="https://pchaigno.github.io/bpf/2021/10/20/ebpf-instruction-sets.html" target="_blank" rel="noreferrer">This blog entry</a> states that BPF ISA version is now <code>v3</code> since kernel version v5.1.</p><p>It seems <a href="https://github.com/dthaler/ebpf-docs/pull/4" target="_blank" rel="noreferrer">people are working to update the kernel documentation</a>, and <a href="https://github.com/dthaler/ebpf-docs/blob/update/isa/kernel.org/instruction-set.rst" target="_blank" rel="noreferrer">the updated version</a> covers most of the content on this page.</p><h2 id="architecture" tabindex="-1">Architecture <a class="header-anchor" href="#architecture" aria-hidden="true">#</a></h2><ul><li>The stack / frame: In terms of eBPF, a stack pointer is just a frame pointer. Each eBPF function call has its own 512-byte stack.</li><li><code>R10</code>: This registers points to the base of the stack, that is, the very end of the stack range (<code>R10[-512 : 0]</code>).</li></ul><h2 id="instruction-encoding" tabindex="-1">Instruction Encoding <a class="header-anchor" href="#instruction-encoding" aria-hidden="true">#</a></h2><p>Instructions are encoded in host endianness.</p><h3 id="wide-instructions" tabindex="-1">Wide instructions <a class="header-anchor" href="#wide-instructions" aria-hidden="true">#</a></h3><p>A wide instruction is a 128-bit instruction:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">| 64-bit insn1 | 64-bit insn2 |</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>While the spec states &quot;the wide instruction encoding... appends a second 64-bit immediate value (imm64) after the basic instruction for a total of 128 bits&quot;, it is not.</p><p>Actually, <code>insn1.imm32</code> is the lower 32 bits and <code>insn2.imm32</code> is the upper 32 bits: <a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/core.c#L1738" target="_blank" rel="noreferrer"><code>___bpf_prog_run#LD_IMM_DW</code></a>.</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">imm64 = insn1.imm32 | (insn2.imm32 &lt;&lt; 32);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="instructions" tabindex="-1">Instructions <a class="header-anchor" href="#instructions" aria-hidden="true">#</a></h2><p>You might want to see how each instruction is actually executed by the verifier. <a href="./../impl/interpreter.html">Here</a> is an incomplete list of them.</p><h3 id="arithmetic-and-jumps" tabindex="-1">Arithmetic and jumps <a class="header-anchor" href="#arithmetic-and-jumps" aria-hidden="true">#</a></h3><ul><li><p><code>BPF_NEG</code>: No, this opcode is not a bitwise-not as the spec states: <code>dst = ~src</code>. <a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/core.c#L1719-L1724" target="_blank" rel="noreferrer">It is actually just <code>DST = -DST;</code></a> and has nothing to do with the <code>src</code> register.</p></li><li><p><code>BPF_DIV</code>, <code>BPF_MOD</code>: An implementation must check for zero divisions. In Linux, they just rewrite that instruction into several, with explicit hard-coded zero checks.</p></li><li><p>In jump instructions, the <code>off</code> (offset) is <code>(current_jump_insn_pc + 1) - target_pc</code>, which is quite straightforward though.</p></li></ul><h3 id="function-calls" tabindex="-1">Function calls <a class="header-anchor" href="#function-calls" aria-hidden="true">#</a></h3><p>The eBPF interpreter/JIT compilers in Linux rely on preprocessing in the verifier. In order to understand how actually function calls work, you will need to get down to the verifier: <a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L13893-L14412" target="_blank" rel="noreferrer"><code>kernel/bpf/verifier.c#do_misc_fixups</code></a></p><p>In short, <code>BPF_CALL</code> has multiple semantics, differentiated by the <code>src_deg</code> field:</p><ul><li><p>Calling a <a href="https://docs.kernel.org/bpf/helpers.html" target="_blank" rel="noreferrer">helper function</a>.</p><ul><li>The <code>src_reg</code> field in the instruction must be zeroed.</li><li>During <a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L14378-L14389" target="_blank" rel="noreferrer"><code>do_misc_fixups</code></a>, the <code>imm32</code> field (which originally contains an ID to the helper function) is replaced with a function pointer relative to <code>__bpf_call_base</code>.</li></ul></li><li><p>Calling one of <a href="https://docs.kernel.org/bpf/kfuncs.html" target="_blank" rel="noreferrer">BPF Kernel Functions (kfuncs)</a>, which requires JIT compilation.</p><ul><li>The <code>src_reg</code> field must be <code>BPF_PSEUDO_KFUNC_CALL</code>.</li><li>During <a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L13868-L13891" target="_blank" rel="noreferrer"><code>fixup_kfunc_call</code></a>, the <code>imm32</code> field is replaced similar to helper function calls.</li></ul></li><li><p>Doing a <code>BPF_PSEUDO_CALL</code>:</p><ul><li>The <code>src_reg</code> field must be <code>BPF_PSEUDO_CALL</code>.</li><li>It is just a relative function call. A libbpf example:<div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki has-highlighted-lines"><code><span class="line"><span style="color:#82AAFF;">SEC</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">some_sec</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">handle</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">my_func</span><span style="color:#89DDFF;">();</span><span style="color:#676E95;"> // BPF_PSEUDO_CALL</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">SEC</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">some_sec</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">my_func</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">bpf_printk</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Pseudo-called</span><span style="color:#A6ACCD;">\\n</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div>A new stack frame is allocated for each call.</li><li>During <a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/core.c#L2067-L2074" target="_blank" rel="noreferrer"><code>bpf_patch_call_args</code></a>, the instruction is replaced with an internal one (<code>JMP_CALL_ARGS</code>).</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>If you are implementing your own eBPF runtime, you don&#39;t need to follow the internals of Linux. All the above explanations just aim to help with reading Linux source code and understanding eBPF semantics.</p></div><h3 id="relocation" tabindex="-1">Relocation <a class="header-anchor" href="#relocation" aria-hidden="true">#</a></h3><p>See <a href="./libbpf.html#maps">libbpf</a> for some info about map relocation.</p><p>(WIP) </p>`,28),i=[o];function l(r,c,p,d,h,u){return n(),t("div",null,i)}const m=e(a,[["render",l]]);export{b as __pageData,m as default};
