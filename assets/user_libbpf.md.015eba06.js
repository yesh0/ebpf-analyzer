import{_ as s,c as a,o as n,a as l}from"./app.3775c9dd.js";const A=JSON.parse('{"title":"Libbpf","description":"","frontmatter":{},"headers":[{"level":2,"title":"A source code reading list","slug":"a-source-code-reading-list","link":"#a-source-code-reading-list","children":[]},{"level":2,"title":"Maps","slug":"maps","link":"#maps","children":[{"level":3,"title":"Global data sections","slug":"global-data-sections","link":"#global-data-sections","children":[]}]}],"relativePath":"user/libbpf.md","lastUpdated":1672991337000}'),p={name:"user/libbpf.md"},o=l(`<h1 id="libbpf" tabindex="-1">Libbpf <a class="header-anchor" href="#libbpf" aria-hidden="true">#</a></h1><p>One may think of <a href="https://github.com/libbpf/libbpf" target="_blank" rel="noreferrer">libbpf</a> as a workflow to get your eBPF programs compiled and run them across different Linux versions.</p><p>It wraps up a lot syscall details and provides a clean user interface: one compiles their eBPF code into a <code>.o</code> file with some headers, passes the <code>.o</code> file to libbpf, and it will automate most of the work.</p><p>By reading the source code, you can actually see how each syscall is used and what exactly <code>bpf_attr</code> means in that context.</p><h2 id="a-source-code-reading-list" tabindex="-1">A source code reading list <a class="header-anchor" href="#a-source-code-reading-list" aria-hidden="true">#</a></h2><ul><li><a href="https://github.com/libbpf/libbpf/blob/68e6f83f223ebf3fbf0d94c0f4592e5e6773f0c1/src/bpf.c#L235-L318" target="_blank" rel="noreferrer">How to construct a <code>bpf_attr</code> for <code>BPF_PROG_LOAD</code></a></li></ul><h2 id="maps" tabindex="-1">Maps <a class="header-anchor" href="#maps" aria-hidden="true">#</a></h2><p>Libbpf provides a convenient way for user to declare and use eBPF maps:</p><ul><li><p>Declaration:</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// Deprecated style (removed in libbpf v1.0)</span></span>
<span class="line"><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> bpf_map_def </span><span style="color:#82AAFF;">SEC</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">maps</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> my_map </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    .type </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> BPF_MAP_TYPE_ARRAY</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    .max_entries </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    .key_size </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">sizeof(</span><span style="color:#C792EA;">int</span><span style="color:#89DDFF;">),</span></span>
<span class="line"><span style="color:#F07178;">    .value_size </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">sizeof(</span><span style="color:#C792EA;">int</span><span style="color:#89DDFF;">),</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#676E95;">// BTF style</span></span>
<span class="line"><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">__uint</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> BPF_MAP_TYPE_ARRAY</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">__uint</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">max_entries</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">__type</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">key</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">int</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">__type</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">int</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> my_map </span><span style="color:#82AAFF;">SEC</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">.maps</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div></li><li><p>Usage:</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> key </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">map </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;">my_map</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">bpf_map_lookup_elem</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">map</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div></li></ul><p>Pretty convenient. To achieve this, libbpf does some work under the hood: the (older) Linux kernel only recognizes map descriptors, which programs obtain by actually creating the map (like file descriptors), so libbpf will have to:</p><ul><li><p>create all the maps needed by the eBPF program(s),</p></li><li><p>and convert all map usages with the map descriptors, e.g.,</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// The original code</span></span>
<span class="line"><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">map </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;">my_map</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;">// The converted code, using map descriptors</span></span>
<span class="line"><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">map </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> injected_map_fd</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>which is part of the relocation process.</p></li></ul><p>Also, to distinguish <code>void *map = injected_map_fd</code> from <code>long map = (long) injected_map_fd</code> (which will get rejected by the verifier), a special kind of instruction is used.</p><h3 id="global-data-sections" tabindex="-1">Global data sections <a class="header-anchor" href="#global-data-sections" aria-hidden="true">#</a></h3><p>Introduced in <a href="https://github.com/torvalds/linux/commit/d859900c4c56dc4f0f8894c92a01dad86917453e" target="_blank" rel="noreferrer"><code>d859900c4c56</code></a>.</p><p>User space programs can access data in their <code>.data</code>, <code>.rodata</code> or <code>.bss</code> sections:</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// Stored in \`.data\` section</span></span>
<span class="line"><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> magic </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0x42</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> magic</span><span style="color:#89DDFF;">++;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;">// Compiled into</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">int</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;">magic </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> runtime_injected_magic_pointer</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(*</span><span style="color:#F07178;">magic</span><span style="color:#89DDFF;">)++;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>However, one cannot inject pointers freely in eBPF programs: the eBPF verifier will need to know about all pointers and user injected ones will very likely get rejected since they don&#39;t look like pointers nor are safe to access.</p><p>To provide functionalities similar to <code>.data</code> sections:</p><ul><li>map value regions are used as data sections,</li><li>the pointer injection job is moved into the kernel space.</li></ul><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// Stored in \`.data\` section</span></span>
<span class="line"><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> magic </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0x42</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> magic</span><span style="color:#89DDFF;">++;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;">// Compiled into</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">int</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;">magic </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">verifier_please_inject_pointer_to_this_map_value</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">fd</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> ...</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(*</span><span style="color:#F07178;">magic</span><span style="color:#89DDFF;">)++;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>Libbpf will still need to create the maps and inject the map descriptor <code>fd</code>.</p>`,21),e=[o];function t(c,r,i,y,F,D){return n(),a("div",null,e)}const C=s(p,[["render",t]]);export{A as __pageData,C as default};
