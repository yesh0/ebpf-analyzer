import{_ as e,c as a,o,a as r}from"./app.3775c9dd.js";const b=JSON.parse('{"title":"Conditional Jump Tracking","description":"","frontmatter":{},"headers":[{"level":2,"title":"check_cond_jmp_op","slug":"check-cond-jmp-op","link":"#check-cond-jmp-op","children":[]},{"level":2,"title":"Register state propagation","slug":"register-state-propagation","link":"#register-state-propagation","children":[]}],"relativePath":"verifier/conditional.md","lastUpdated":1672991337000}'),t={name:"verifier/conditional.md"},i=r(`<h1 id="conditional-jump-tracking" tabindex="-1">Conditional Jump Tracking <a class="header-anchor" href="#conditional-jump-tracking" aria-hidden="true">#</a></h1><p><a href="./verifier.html#do-check"><code>do_check</code></a> calls <a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L10117" target="_blank" rel="noreferrer"><code>check_cond_jmp_op</code></a> to update tracked values and diverge the execution path.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Among <code>JMP/JMP32</code> opcodes, there are some other instructions:</p><ul><li><code>BPF_CALL</code>: <a href="./functions.html">Function calls</a></li><li><code>BPF_EXIT</code>: Returns</li><li><code>BPF_JA</code>: Unconditional jumps</li></ul><p><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L12360-L12450" target="_blank" rel="noreferrer">Verifying them</a> is done elsewhere.</p></div><h2 id="check-cond-jmp-op" tabindex="-1"><code>check_cond_jmp_op</code> <a class="header-anchor" href="#check-cond-jmp-op" aria-hidden="true">#</a></h2><p>Some important functions that it calls (i.e., those functions that it passes an <code>opcode</code> parameter):</p><ul><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L9634" target="_blank" rel="noreferrer"><code>is_branch_taken</code></a>: According to the comments, it will <code>compute branch direction of the expression &quot;if (reg opcode val) goto target;&quot;</code>.</li><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L9919" target="_blank" rel="noreferrer"><code>reg_combine_min_max</code></a>: With <code>BPF_JEQ</code> for example, <code>a == b</code> means that they share the same set of possible values and this can be used to narrow down the their ranges.</li><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L9728" target="_blank" rel="noreferrer"><code>reg_set_min_max</code></a>: Adjusts the ranges of scalars for branches after comparison like <code>a &lt; constant</code> or <code>a &gt;= constant</code>, etc.</li><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L9888" target="_blank" rel="noreferrer"><code>reg_set_min_max_inv</code></a>: Wrapper of <code>reg_set_min_max</code> with inverted parameter pair (e.g., <code>constant &gt; b</code>).</li><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L10105" target="_blank" rel="noreferrer"><code>find_equal_scalars</code></a>: Seems to propagate scalar info to other registers that were assigned the same value.</li></ul><p>Pointer comparison:</p><ul><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L9980" target="_blank" rel="noreferrer"><code>mark_ptr_or_null_regs</code></a>: Mark non-null / null pointers.</li><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L10000" target="_blank" rel="noreferrer"><code>try_match_pkt_pointers</code></a>: Pattern matching packet pointer comparison, gathering packet size info.</li></ul><p>Some straightforward checks:</p><ul><li>Disallowing pointer comparison unless <code>allow_ptr_leaks</code> is on.</li></ul><p>(WIP)</p><h2 id="register-state-propagation" tabindex="-1">Register state propagation <a class="header-anchor" href="#register-state-propagation" aria-hidden="true">#</a></h2><p>Sometimes you have too many variables in your program and the compiler has to spill them onto the stack. (Or if you are using <code>clang -O0</code>, then all variables are allocated on the stack by default.)</p><p>Now consider the following scenario (in pseudo eBPF assembly):</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">call func1             # return values is stored in r0</span></span>
<span class="line"><span style="color:#A6ACCD;">*(u64*)(r10 - 8) = r0  # spilling r0 onto stack</span></span>
<span class="line"><span style="color:#A6ACCD;">...                    # doing other stuff</span></span>
<span class="line"><span style="color:#A6ACCD;">r1 = *(u64*)(r10 - 8)  # getting the value back</span></span>
<span class="line"><span style="color:#A6ACCD;">if r1 &gt; 1000 goto +20  # conditional jump</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>We know that <code>r1 = *(u64*)(r10 - 8)</code>. So if <code>r1 &gt; 1000</code>, we believe <code>*(u64*)(r10 - 8) &gt; 100</code> holds as well. The eBPF verifier puts some effort into passing these information around by doing the following:</p><ol><li>Assign each value a unique id; <ul><li>The id is generated from <code>++env-&gt;id_gen</code>. Since the verifier limits the number of total instructions in a verification branch, we should be safe from overflowing the <code>u32</code> field.</li></ul></li><li>Pass the id on when copying values;</li><li>Clear the id field each time the value gets changed.</li></ol><p>Read the source code for more information:</p><ul><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/include/linux/bpf_verifier.h#L347" target="_blank" rel="noreferrer"><code>bpf_verifier.h#bpf_for_each_spilled_reg</code></a>: The verifier walks through the whole allocated stack for spilled registers.</li><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/include/linux/bpf_verifier.h#L353" target="_blank" rel="noreferrer"><code>bpf_verifier.h#bpf_for_each_reg_in_vstate</code></a>: A macro to iterate through all register values (including spilled ones).</li><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/include/linux/bpf_verifier.h#L507" target="_blank" rel="noreferrer"><code>struct bpf_verifier_env</code></a>: The <code>id_gen</code> field is used to generate unique ids for values and pointers. (You can search for <code>++env-&gt;id_gen</code> in <code>verifier.c</code> for its usages.</li><li><a href="https://github.com/torvalds/linux/blob/4dc12f37a8e98e1dca5521c14625c869537b50b6/kernel/bpf/verifier.c#L10105-L10115" target="_blank" rel="noreferrer"><code>verifier.c#find_equal_scalars</code></a>: Propagates a value to registers of the same id.</li></ul>`,19),c=[i];function n(l,s,d,p,h,f){return o(),a("div",null,c)}const g=e(t,[["render",n]]);export{b as __pageData,g as default};
