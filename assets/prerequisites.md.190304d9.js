import{_ as e,c as t,o as i,a as r}from"./app.3775c9dd.js";const f=JSON.parse('{"title":"Prelude","description":"","frontmatter":{},"headers":[{"level":2,"title":"Who this documentation is for","slug":"who-this-documentation-is-for","link":"#who-this-documentation-is-for","children":[]},{"level":2,"title":"Prerequisites","slug":"prerequisites","link":"#prerequisites","children":[{"level":3,"title":"JIT or AOT","slug":"jit-or-aot","link":"#jit-or-aot","children":[]}]}],"relativePath":"prerequisites.md","lastUpdated":1672991337000}'),o={name:"prerequisites.md"},a=r('<h1 id="prelude" tabindex="-1">Prelude <a class="header-anchor" href="#prelude" aria-hidden="true">#</a></h1><h2 id="who-this-documentation-is-for" tabindex="-1">Who this documentation is for <a class="header-anchor" href="#who-this-documentation-is-for" aria-hidden="true">#</a></h2><p>Most literature on the Internet documents eBPF from a user&#39;s perspective. However, for <em><strong>OS developers</strong></em> or someone <em><strong>who just needs to write an eBPF implementation</strong></em> from scratch for whatever reason, they will most likely have to turn to the Linux source code due to a lack of documentation.</p><p>This site is an attempt to provide some implementation details of eBPF in Linux, in the hope that it will pick up some hitchhikers on the way.</p><h2 id="prerequisites" tabindex="-1">Prerequisites <a class="header-anchor" href="#prerequisites" aria-hidden="true">#</a></h2><p>I assume that you have already heard about eBPF as well as the following concepts before:</p><ul><li><a href="https://docs.cilium.io/en/latest/bpf/#instruction-set" target="_blank" rel="noreferrer">eBPF instruction set</a><ul><li>eBPF virtual machine</li><li>eBPF byte code</li></ul></li><li><a href="https://docs.kernel.org/bpf/helpers.html" target="_blank" rel="noreferrer">eBPF helper functions</a></li><li>eBPF interpreter</li><li><a href="https://docs.kernel.org/bpf/verifier.html" target="_blank" rel="noreferrer">eBPF verifier</a></li><li><a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer" target="_blank" rel="noreferrer">Reduced Instruction Set Computer (RISC)</a></li><li><a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noreferrer">Just-In-Time (JIT) compilation</a></li><li><a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation" target="_blank" rel="noreferrer">Ahead-Of-Time (AOT) compilation</a></li><li><a href="https://en.wikipedia.org/wiki/Relocation_(computing)" target="_blank" rel="noreferrer">Relocation</a></li></ul><p>We will get to these concepts soon.</p><h3 id="jit-or-aot" tabindex="-1">JIT or AOT <a class="header-anchor" href="#jit-or-aot" aria-hidden="true">#</a></h3><p>We are not going to distinguish between JIT and AOT. But it can be fun if you think about it:</p><ul><li>From the user&#39;s perspective, the kernel does JIT compilation, since the compilation is done after they request to run the program.</li><li>As for eBPF implementers, it is actually AOT: compilation is done before running the code. <ul><li>No, we are not to discuss those complex techniques used by Java or C#.</li><li>It might eventually evolve into a JIT implementation, but personally I think it is just too slow during warm-up and not worth the price.</li></ul></li></ul>',11),n=[a];function s(l,h,u,c,d,p){return i(),t("div",null,n)}const _=e(o,[["render",s]]);export{f as __pageData,_ as default};
